<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" src="../../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>API · DynamicPPL</title><script data-outdated-warner="" src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/><link href="../../../../assets/multidoc-custom.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><div class="nav-dropdown"><button class="nav-item dropdown-label">Modelling languages</button><ul class="nav-dropdown-container"><a class="nav-link active nav-item" href="../../../">DynamicPPL</a><a class="nav-link nav-item" href="../../../../JuliaBUGS/">JuliaBUGS</a><a class="nav-link nav-item" href="../../../../TuringGLM/">TuringGLM</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">MCMC</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../../AdvancedHMC/">AdvancedHMC</a><a class="nav-link nav-item" href="../../../../AbstractMCMC/">AbstractMCMC</a><a class="nav-link nav-item" href="../../../../ThermodynamicIntegration/">ThermodynamicIntegration</a><a class="nav-link nav-item" href="../../../../AdvancedPS/">AdvancedPS</a><a class="nav-link nav-item" href="../../../../EllipticalSliceSampling/">EllipticalSliceSampling</a><a class="nav-link nav-item" href="../../../../NestedSamplers/">NestedSamplers</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Diagnostics</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../../MCMCChains/">MCMCChains</a><a class="nav-link nav-item" href="../../../../MCMCDiagnosticTools/">MCMCDiagnosticTools</a><a class="nav-link nav-item" href="../../../../ParetoSmooth/">ParetoSmooth</a></ul></div><a class="nav-link nav-item" href="../../../../Bijectors/">Bijectors</a><a class="nav-link nav-item" href="../../../../TuringCallbacks/">TuringCallbacks</a><a class="nav-link nav-item" href="../../../../TuringBenchmarking/">TuringBenchmarking</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Gaussian Processes</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../../AbstractGPs/">AbstractGPs</a><a class="nav-link nav-item" href="../../../../KernelFunctions/">KernelFunctions</a><a class="nav-link nav-item" href="../../../../ApproximateGPs/">ApproximateGPs</a></ul></div><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding"></div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="DynamicPPL logo" src="../assets/logo.svg"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DynamicPPL</a></span></div><form action="../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href="">API</a><ul class="internal"><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Condition-and-decondition"><span>Condition and decondition</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Testing-Utilities"><span>Testing Utilities</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/prob-interface/">The Probability Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/DynamicPPL.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>Part of the API of DynamicPPL is defined in the more lightweight interface package <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> and reexported here.</p><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><p>A core component of DynamicPPL is the <a href="#DynamicPPL.@model"><code>@model</code></a> macro. It can be used to define probabilistic models in an intuitive way by specifying random variables and their distributions with <code>~</code> statements. These statements are rewritten by <code>@model</code> as calls of <a href="#model_internal">internal functions</a> for sampling the variables and computing their log densities.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.@model" id="DynamicPPL.@model"><code>DynamicPPL.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@model(expr[, warn = false])</code></pre><p>Macro to specify a probabilistic model.</p><p>If <code>warn</code> is <code>true</code>, a warning is displayed if internal variable names are used in the model definition.</p><p><strong>Examples</strong></p><p>Model definition:</p><pre><code class="language-julia hljs">@model function model(x, y = 42)
    ...
end</code></pre><p>To generate a <code>Model</code>, call <code>model(xvalue)</code> or <code>model(xvalue, yvalue)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/compiler.jl#L185-L204" target="_blank">source</a></section></article><p>One can nest models and call another model inside the model function with <a href="#DynamicPPL.@submodel"><code>@submodel</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.@submodel" id="DynamicPPL.@submodel"><code>DynamicPPL.@submodel</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@submodel model
@submodel ... = model</code></pre><p>Run a Turing <code>model</code> nested inside of a Turing model.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y)
            @submodel a = demo1(x)
            return y ~ Uniform(0, a)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, 0.4)</code> random variable <code>x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, 0.4));

julia&gt; @varname(x) in keys(vi)
true</code></pre><p>Variable <code>a</code> is not tracked since it can be computed from the random variable <code>x</code> that was tracked when running <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; x = vi[@varname(x)];

julia&gt; getlogp(vi) ≈ logpdf(Normal(), x) + logpdf(Uniform(0, 1 + abs(x)), 0.4)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/submodel_macro.jl#L1-L44" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">@submodel prefix=... model
@submodel prefix=... ... = model</code></pre><p>Run a Turing <code>model</code> nested inside of a Turing model and add "<code>prefix</code>." as a prefix to all random variables inside of the <code>model</code>.</p><p>Valid expressions for <code>prefix=...</code> are:</p><ul><li><code>prefix=false</code>: no prefix is used.</li><li><code>prefix=true</code>: <em>attempt</em> to automatically determine the prefix from the left-hand side <code>... = model</code> by first converting into a <code>VarName</code>, and then calling <code>Symbol</code> on this.</li><li><code>prefix=expression</code>: results in the prefix <code>Symbol(expression)</code>.</li></ul><p>The prefix makes it possible to run the same Turing model multiple times while keeping track of all random variables correctly.</p><p><strong>Examples</strong></p><p><strong>Example models</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo1(x)
           x ~ Normal()
           return 1 + abs(x)
       end;

julia&gt; @model function demo2(x, y, z)
            @submodel prefix="sub1" a = demo1(x)
            @submodel prefix="sub2" b = demo1(y)
            return z ~ Uniform(-a, b)
       end;</code></pre><p>When we sample from the model <code>demo2(missing, missing, 0.4)</code> random variables <code>sub1.x</code> and <code>sub2.x</code> will be sampled:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = VarInfo(demo2(missing, missing, 0.4));

julia&gt; @varname(var"sub1.x") in keys(vi)
true

julia&gt; @varname(var"sub2.x") in keys(vi)
true</code></pre><p>Variables <code>a</code> and <code>b</code> are not tracked since they can be computed from the random variables <code>sub1.x</code> and <code>sub2.x</code> that were tracked when running <code>demo1</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; @varname(a) in keys(vi)
false

julia&gt; @varname(b) in keys(vi)
false</code></pre><p>We can check that the log joint probability of the model accumulated in <code>vi</code> is correct:</p><pre><code class="language-julia-repl hljs">julia&gt; sub1_x = vi[@varname(var"sub1.x")];

julia&gt; sub2_x = vi[@varname(var"sub2.x")];

julia&gt; logprior = logpdf(Normal(), sub1_x) + logpdf(Normal(), sub2_x);

julia&gt; loglikelihood = logpdf(Uniform(-1 - abs(sub1_x), 1 + abs(sub2_x)), 0.4);

julia&gt; getlogp(vi) ≈ logprior + loglikelihood
true</code></pre><p><strong>Different ways of setting the prefix</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model inner() = x ~ Normal()
inner (generic function with 2 methods)

julia&gt; # When `prefix` is unspecified, no prefix is used.
       @model outer() = @submodel a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(x) in keys(VarInfo(outer()))
true

julia&gt; # Explicitely don't use any prefix.
       @model outer() = @submodel prefix=false a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(x) in keys(VarInfo(outer()))
true

julia&gt; # Automatically determined from `a`.
       @model outer() = @submodel prefix=true a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var"a.x") in keys(VarInfo(outer()))
true

julia&gt; # Using a static string.
       @model outer() = @submodel prefix="my prefix" a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var"my prefix.x") in keys(VarInfo(outer()))
true

julia&gt; # Using string interpolation.
       @model outer() = @submodel prefix="$(nameof(inner()))" a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var"inner.x") in keys(VarInfo(outer()))
true

julia&gt; # Or using some arbitrary expression.
       @model outer() = @submodel prefix=1 + 2 a = inner()
outer (generic function with 2 methods)

julia&gt; @varname(var"3.x") in keys(VarInfo(outer()))
true

julia&gt; # (×) Automatic prefixing without a left-hand side expression does not work!
       @model outer() = @submodel prefix=true inner()
ERROR: LoadError: cannot automatically prefix with no left-hand side
[...]</code></pre><p><strong>Notes</strong></p><ul><li>The choice <code>prefix=expression</code> means that the prefixing will incur a runtime cost. This is also the case for <code>prefix=true</code>, depending on whether the expression on the the right-hand side of <code>... = model</code> requires runtime-information or not, e.g. <code>x = model</code> will result in the <em>static</em> prefix <code>x</code>, while <code>x[i] = model</code> will be resolved at runtime.</li></ul></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/submodel_macro.jl#L49-L176" target="_blank">source</a></section></article><h3 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h3><p>A <a href="#DynamicPPL.Model"><code>Model</code></a> can be created by calling the model function, as defined by <a href="#DynamicPPL.@model"><code>@model</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.Model" id="DynamicPPL.Model"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Model{F,argnames,defaultnames,missings,Targs,Tdefaults}
    f::F
    args::NamedTuple{argnames,Targs}
    defaults::NamedTuple{defaultnames,Tdefaults}
end</code></pre><p>A <code>Model</code> struct with model evaluation function of type <code>F</code>, arguments of names <code>argnames</code> types <code>Targs</code>, default arguments of names <code>defaultnames</code> with types <code>Tdefaults</code>, and missing arguments <code>missings</code>.</p><p>Here <code>argnames</code>, <code>defaultargnames</code>, and <code>missings</code> are tuples of symbols, e.g. <code>(:a, :b)</code>.</p><p>An argument with a type of <code>Missing</code> will be in <code>missings</code> by default. However, in non-traditional use-cases <code>missings</code> can be defined differently. All variables in <code>missings</code> are treated as random variables rather than observations.</p><p>The default arguments are used internally when constructing instances of the same model with different arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; Model(f, (x = 1.0, y = 2.0))
Model{typeof(f),(:x, :y),(),(),Tuple{Float64,Float64},Tuple{}}(f, (x = 1.0, y = 2.0), NamedTuple())

julia&gt; Model(f, (x = 1.0, y = 2.0), (x = 42,))
Model{typeof(f),(:x, :y),(:x,),(),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))

julia&gt; Model{(:y,)}(f, (x = 1.0, y = 2.0), (x = 42,)) # with special definition of missings
Model{typeof(f),(:x, :y),(:x,),(:y,),Tuple{Float64,Float64},Tuple{Int64}}(f, (x = 1.0, y = 2.0), (x = 42,))</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L1-L33" target="_blank">source</a></section></article><p><a href="#DynamicPPL.Model"><code>Model</code></a>s are callable structs.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.Model-Tuple{}" id="DynamicPPL.Model-Tuple{}"><code>DynamicPPL.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(model::Model)([rng, varinfo, sampler, context])</code></pre><p>Sample from the <code>model</code> using the <code>sampler</code> with random number generator <code>rng</code> and the <code>context</code>, and store the sample and log joint probability in <code>varinfo</code>.</p><p>The method resets the log joint probability of <code>varinfo</code> and increases the evaluation number of <code>sampler</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L466-L474" target="_blank">source</a></section></article><p>Basic properties of a model can be accessed with <a href="#DynamicPPL.getargnames"><code>getargnames</code></a>, <a href="#DynamicPPL.getmissings"><code>getmissings</code></a>, and <a href="#Base.nameof-Tuple{Model}"><code>nameof</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#Base.nameof-Tuple{Model}" id="Base.nameof-Tuple{Model}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nameof(model::Model)</code></pre><p>Get the name of the <code>model</code> as <code>Symbol</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L620-L624" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.getargnames" id="DynamicPPL.getargnames"><code>DynamicPPL.getargnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getargnames(model::Model)</code></pre><p>Get a tuple of the argument names of the <code>model</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L606-L610" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.getmissings" id="DynamicPPL.getmissings"><code>DynamicPPL.getmissings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getmissings(model::Model)</code></pre><p>Get a tuple of the names of the missing arguments of the <code>model</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L613-L617" target="_blank">source</a></section></article><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>With <a href="#Base.rand"><code>rand</code></a> one can draw samples from the prior distribution of a <a href="#DynamicPPL.Model"><code>Model</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#Base.rand" id="Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand([rng=Random.default_rng()], [T=NamedTuple], model::Model)</code></pre><p>Generate a sample of type <code>T</code> from the prior distribution of the <code>model</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L628-L632" target="_blank">source</a></section></article><p>One can also evaluate the log prior, log likelihood, and log joint probability.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.logprior" id="DynamicPPL.logprior"><code>DynamicPPL.logprior</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logprior(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log prior probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L660-L666" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">logprior(model::Model, θ)</code></pre><p>Return the log prior probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logprior(demo([1.0]), (m = 100.0, ))
-5000.918938533205

julia&gt; # Using a `OrderedDict`.
       logprior(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-5000.918938533205

julia&gt; # Truth.
       logpdf(Normal(), 100.0)
-5000.918938533205</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/simple_varinfo.jl#L585-L614" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#StatsAPI.loglikelihood" id="StatsAPI.loglikelihood"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglikelihood(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log likelihood of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L671-L677" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">loglikelihood(model::Model, θ)</code></pre><p>Return the log likelihood of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See also <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#DynamicPPL.logprior"><code>logprior</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       loglikelihood(demo([1.0]), (m = 100.0, ))
-4901.418938533205

julia&gt; # Using a `OrderedDict`.
       loglikelihood(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-4901.418938533205

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0)
-4901.418938533205</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/simple_varinfo.jl#L617-L646" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.logjoint" id="DynamicPPL.logjoint"><code>DynamicPPL.logjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logjoint(model::Model, varinfo::AbstractVarInfo)</code></pre><p>Return the log joint probability of variables <code>varinfo</code> for the probabilistic <code>model</code>.</p><p>See <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L649-L655" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">logjoint(model::Model, θ)</code></pre><p>Return the log joint probability of variables <code>θ</code> for the probabilistic <code>model</code>.</p><p>See <a href="#DynamicPPL.logjoint"><code>logjoint</code></a> and <a href="#StatsAPI.loglikelihood"><code>loglikelihood</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ Normal()
           for i in eachindex(x)
               x[i] ~ Normal(m, 1.0)
           end
       end
demo (generic function with 2 methods)

julia&gt; # Using a `NamedTuple`.
       logjoint(demo([1.0]), (m = 100.0, ))
-9902.33787706641

julia&gt; # Using a `OrderedDict`.
       logjoint(demo([1.0]), OrderedDict(@varname(m) =&gt; 100.0))
-9902.33787706641

julia&gt; # Truth.
       logpdf(Normal(100.0, 1.0), 1.0) + logpdf(Normal(), 100.0)
-9902.33787706641</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/simple_varinfo.jl#L553-L582" target="_blank">source</a></section></article><h3 id="LogDensityProblems.jl-interface"><a class="docs-heading-anchor" href="#LogDensityProblems.jl-interface">LogDensityProblems.jl interface</a><a id="LogDensityProblems.jl-interface-1"></a><a class="docs-heading-anchor-permalink" href="#LogDensityProblems.jl-interface" title="Permalink"></a></h3><p>The <a href="https://github.com/tpapp/LogDensityProblems.jl">LogDensityProblems.jl</a> interface is also supported by simply wrapping a <a href="#DynamicPPL.Model"><code>Model</code></a> in a <code>DynamicPPL.LogDensityFunction</code>:</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.LogDensityFunction" id="DynamicPPL.LogDensityFunction"><code>DynamicPPL.LogDensityFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogDensityFunction</code></pre><p>A callable representing a log density function of a <code>model</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>varinfo</code>: varinfo used for evaluation</p></li><li><p><code>model</code>: model used for evaluation</p></li><li><p><code>context</code>: context used for evaluation</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: LogDensityFunction, contextualize

julia&gt; @model function demo(x)
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; model = demo(1.0);

julia&gt; f = LogDensityFunction(model);

julia&gt; # It implements the interface of LogDensityProblems.jl.
       using LogDensityProblems

julia&gt; LogDensityProblems.logdensity(f, [0.0])
-2.3378770664093453

julia&gt; LogDensityProblems.dimension(f)
1

julia&gt; # By default it uses `VarInfo` under the hood, but this is not necessary.
       f = LogDensityFunction(model, SimpleVarInfo(model));

julia&gt; LogDensityProblems.logdensity(f, [0.0])
-2.3378770664093453

julia&gt; # This also respects the context in `model`.
       f_prior = LogDensityFunction(contextualize(model, DynamicPPL.PriorContext()), VarInfo(model));

julia&gt; LogDensityProblems.logdensity(f_prior, [0.0]) == logpdf(Normal(), 0.0)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/logdensityfunction.jl#L1-L46" target="_blank">source</a></section></article><h2 id="Condition-and-decondition"><a class="docs-heading-anchor" href="#Condition-and-decondition">Condition and decondition</a><a id="Condition-and-decondition-1"></a><a class="docs-heading-anchor-permalink" href="#Condition-and-decondition" title="Permalink"></a></h2><p>A <a href="#DynamicPPL.Model"><code>Model</code></a> can be conditioned on a set of observations with <a href="#AbstractPPL.condition"><code>AbstractPPL.condition</code></a> or its alias <a href="#Base.:|-Tuple{Model, Any}"><code>|</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#Base.:|-Tuple{Model, Any}" id="Base.:|-Tuple{Model, Any}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model | (x = 1.0, ...)</code></pre><p>Return a <code>Model</code> which now treats variables on the right-hand side as observations.</p><p>See <a href="#AbstractPPL.condition"><code>condition</code></a> for more information and examples.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L81-L87" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#AbstractPPL.condition" id="AbstractPPL.condition"><code>AbstractPPL.condition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">condition(model::Model; values...)
condition(model::Model, values::NamedTuple)</code></pre><p>Return a <code>Model</code> which now treats the variables in <code>values</code> as observations.</p><p>See also: <a href="#AbstractPPL.decondition"><code>decondition</code></a>, <a href="#DynamicPPL.conditioned"><code>conditioned</code></a></p><p><strong>Limitations</strong></p><p>This does currently <em>not</em> work with variables that are provided to the model as arguments, e.g. <code>@model function demo(x) ... end</code> means that <code>condition</code> will not affect the variable <code>x</code>.</p><p>Therefore if one wants to make use of <code>condition</code> and <a href="#AbstractPPL.decondition"><code>decondition</code></a> one should not be specifying any random variables as arguments.</p><p>This is done for the sake of backwards compatibility.</p><p><strong>Examples</strong></p><p><strong>Simple univariate model</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; model = demo();

julia&gt; m, x = model(); (m ≠ 1.0 &amp;&amp; x ≠ 100.0)
true

julia&gt; # Create a new instance which treats `x` as observed
       # with value `100.0`, and similarly for `m=1.0`.
       conditioned_model = condition(model, x=100.0, m=1.0);

julia&gt; m, x = conditioned_model(); (m == 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # Let's only condition on `x = 100.0`.
       conditioned_model = condition(model, x = 100.0);

julia&gt; m, x =conditioned_model(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # We can also use the nicer `|` syntax.
       conditioned_model = model | (x = 100.0, );

julia&gt; m, x = conditioned_model(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p>The above uses a <code>NamedTuple</code> to hold the conditioning variables, which allows us to perform some additional optimizations; in many cases, the above has zero runtime-overhead.</p><p>But we can also use a <code>Dict</code>, which offers more flexibility in the conditioning (see examples further below) but generally has worse performance than the <code>NamedTuple</code> approach:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = condition(model, Dict(@varname(x) =&gt; 100.0));

julia&gt; m, x = conditioned_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true

julia&gt; # There's also an option using `|` by letting the right-hand side be a tuple
       # with elements of type `Pair{&lt;:VarName}`, i.e. `vn =&gt; value` with `vn isa VarName`.
       conditioned_model_dict = model | (@varname(x) =&gt; 100.0, );

julia&gt; m, x = conditioned_model_dict(); (m ≠ 1.0 &amp;&amp; x == 100.0)
true</code></pre><p><strong>Condition only a part of a multivariate variable</strong></p><p>Not only can be condition on multivariate random variables, but we can also use the standard mechanism of setting something to <code>missing</code> in the call to <code>condition</code> to only condition on a part of the variable.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 3 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, m = [missing, 1.0]);

julia&gt; # (✓) `m[1]` sampled while `m[2]` is fixed
       m = conditioned_model(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p>Intuitively one might also expect to be able to write <code>model | (m[1] = 1.0, )</code>. Unfortunately this is not supported as it has the potential of increasing compilation times but without offering any benefit with respect to runtime:</p><pre><code class="language-julia-repl hljs">julia&gt; # (×) `m[2]` is not set to 1.0.
       m = condition(model, var"m[2]" = 1.0)(); m[2] == 1.0
false</code></pre><p>But you <em>can</em> do this if you use a <code>Dict</code> as the underlying storage instead:</p><pre><code class="language-julia-repl hljs">julia&gt; # Alternatives:
       # - `model | (@varname(m[2]) =&gt; 1.0,)`
       # - `condition(model, Dict(@varname(m[2] =&gt; 1.0)))`
       # (✓) `m[2]` is set to 1.0.
       m = condition(model, @varname(m[2]) =&gt; 1.0)(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 1.0)
true</code></pre><p><strong>Nested models</strong></p><p><code>condition</code> of course also supports the use of nested models through the use of <a href="#DynamicPPL.@submodel"><code>@submodel</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_inner() = m ~ Normal()
demo_inner (generic function with 2 methods)

julia&gt; @model function demo_outer()
           @submodel m = demo_inner()
           return m
       end
demo_outer (generic function with 2 methods)

julia&gt; model = demo_outer();

julia&gt; model() ≠ 1.0
true

julia&gt; conditioned_model = model | (m = 1.0, );

julia&gt; conditioned_model()
1.0</code></pre><p>But one needs to be careful when prefixing variables in the nested models:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_outer_prefix()
           @submodel prefix="inner" m = demo_inner()
           return m
       end
demo_outer_prefix (generic function with 2 methods)

julia&gt; # (×) This doesn't work now!
       conditioned_model = demo_outer_prefix() | (m = 1.0, );

julia&gt; conditioned_model() == 1.0
false

julia&gt; # (✓) `m` in `demo_inner` is referred to as `inner.m` internally, so we do:
       conditioned_model = demo_outer_prefix() | (var"inner.m" = 1.0, );

julia&gt; conditioned_model()
1.0

julia&gt; # Note that the above `var"..."` is just standard Julia syntax:
       keys((var"inner.m" = 1.0, ))
(Symbol("inner.m"),)</code></pre><p>And similarly when using <code>Dict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = demo_outer_prefix() | (@varname(var"inner.m") =&gt; 1.0);

julia&gt; conditioned_model_dict()
1.0</code></pre><p>The difference is maybe more obvious once we look at how these different in their trace/<code>VarInfo</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; keys(VarInfo(demo_outer()))
1-element Vector{VarName{:m, Setfield.IdentityLens}}:
 m

julia&gt; keys(VarInfo(demo_outer_prefix()))
1-element Vector{VarName{Symbol("inner.m"), Setfield.IdentityLens}}:
 inner.m</code></pre><p>From this we can tell what the correct way to condition <code>m</code> within <code>demo_inner</code> is in the two different models.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L90-L289" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">condition([context::AbstractContext,] values::NamedTuple)
condition([context::AbstractContext]; values...)</code></pre><p>Return <code>ConditionContext</code> with <code>values</code> and <code>context</code> if <code>values</code> is non-empty, otherwise return <code>context</code> which is <a href="#DynamicPPL.DefaultContext"><code>DefaultContext</code></a> by default.</p><p>See also: <a href="#AbstractPPL.decondition"><code>decondition</code></a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L387-L395" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.conditioned" id="DynamicPPL.conditioned"><code>DynamicPPL.conditioned</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conditioned(model::Model)</code></pre><p>Return <code>NamedTuple</code> of values that are conditioned on under <code>model</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; using DynamicPPL: conditioned, contextualize

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; # Returns all the variables we have conditioned on + their values.
       conditioned(condition(m, x=100.0, m=1.0))
(x = 100.0, m = 1.0)

julia&gt; # Nested ones also work (note that `PrefixContext` does nothing to the result).
       cm = condition(contextualize(m, PrefixContext{:a}(condition(m=1.0))), x=100.0);

julia&gt; conditioned(cm)
(x = 100.0, m = 1.0)

julia&gt; # Since we conditioned on `m`, not `a.m` as it will appear after prefixed,
       # `a.m` is treated as a random variable.
       keys(VarInfo(cm))
1-element Vector{VarName{Symbol("a.m"), Setfield.IdentityLens}}:
 a.m

julia&gt; # If we instead condition on `a.m`, `m` in the model will be considered an observation.
       cm = condition(contextualize(m, PrefixContext{:a}(condition(var"a.m"=1.0))), x=100.0);

julia&gt; conditioned(cm).x
100.0

julia&gt; conditioned(cm).var"a.m"
1.0

julia&gt; keys(VarInfo(cm)) # &lt;= no variables are sampled
VarName[]</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L416-L463" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">conditioned(context::AbstractContext)</code></pre><p>Return <code>NamedTuple</code> of values that are conditioned on under context`.</p><p>Note that this will recursively traverse the context stack and return a merged version of the condition values.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L471-L478" target="_blank">source</a></section></article><p>Similarly, one can specify with <a href="#AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> that certain, or all, random variables are not observed.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractPPL.decondition" id="AbstractPPL.decondition"><code>AbstractPPL.decondition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decondition(model::Model)
decondition(model::Model, variables...)</code></pre><p>Return a <code>Model</code> for which <code>variables...</code> are <em>not</em> considered observations. If no <code>variables</code> are provided, then all variables currently considered observations will no longer be.</p><p>This is essentially the inverse of <a href="#AbstractPPL.condition"><code>condition</code></a>. This also means that it suffers from the same limitiations.</p><p>Note that currently we only support <code>variables</code> to take on explicit values provided to `condition.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; @model function demo()
           m ~ Normal()
           x ~ Normal(m, 1)
           return (; m=m, x=x)
       end
demo (generic function with 2 methods)

julia&gt; conditioned_model = condition(demo(), m = 1.0, x = 10.0);

julia&gt; conditioned_model()
(m = 1.0, x = 10.0)

julia&gt; # By specifying the `VarName` to `decondition`.
       model = decondition(conditioned_model, @varname(m));

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # When `NamedTuple` is used as the underlying, you can also provide
       # the symbol directly (though the `@varname` approach is preferable if
       # if the variable is known at compile-time).
       model = decondition(conditioned_model, :m);

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true

julia&gt; # `decondition` multiple at once:
       (m, x) = decondition(model, :m, :x)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # `decondition` without any symbols will `decondition` all variables.
       (m, x) = decondition(model)(); (m ≠ 1.0 &amp;&amp; x ≠ 10.0)
true

julia&gt; # Usage of `Val` to perform `decondition` at compile-time if possible
       # is also supported.
       model = decondition(conditioned_model, Val{:m}());

julia&gt; (m, x) = model(); (m ≠ 1.0 &amp;&amp; x == 10.0)
true</code></pre><p>Similarly when using a <code>Dict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; conditioned_model_dict = condition(demo(), @varname(m) =&gt; 1.0, @varname(x) =&gt; 10.0);

julia&gt; conditioned_model_dict()
(m = 1.0, x = 10.0)

julia&gt; deconditioned_model_dict = decondition(conditioned_model_dict, @varname(m));

julia&gt; (m, x) = deconditioned_model_dict(); m ≠ 1.0 &amp;&amp; x == 10.0
true</code></pre><p>But, as mentioned, <code>decondition</code> is only supported for variables explicitly provided to <code>condition</code> earlier;</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo_mv(::Type{TV}=Float64) where {TV}
           m = Vector{TV}(undef, 2)
           m[1] ~ Normal()
           m[2] ~ Normal()
           return m
       end
demo_mv (generic function with 3 methods)

julia&gt; model = demo_mv();

julia&gt; conditioned_model = condition(model, @varname(m) =&gt; [1.0, 2.0]);

julia&gt; conditioned_model()
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; deconditioned_model = decondition(conditioned_model, @varname(m[1]));

julia&gt; deconditioned_model()  # (×) `m[1]` is still conditioned
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; # (✓) this works though
       deconditioned_model_2 = deconditioned_model | (@varname(m[1]) =&gt; missing);

julia&gt; m = deconditioned_model_2(); (m[1] ≠ 1.0 &amp;&amp; m[2] == 2.0)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L295-L404" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">decondition(context::AbstractContext, syms...)</code></pre><p>Return <code>context</code> but with <code>syms</code> no longer conditioned on.</p><p>Note that this recursively traverses contexts, deconditioning all along the way.</p><p>See also: <a href="#AbstractPPL.condition"><code>condition</code></a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L424-L432" target="_blank">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><p>It is possible to manually increase (or decrease) the accumulated log density from within a model function.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.@addlogprob!" id="DynamicPPL.@addlogprob!"><code>DynamicPPL.@addlogprob!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@addlogprob!(ex)</code></pre><p>Add the result of the evaluation of <code>ex</code> to the joint log probability.</p><p><strong>Examples</strong></p><p>This macro allows you to <a href="https://github.com/TuringLang/Turing.jl/issues/1332">include arbitrary terms in the likelihood</a></p><pre><code class="language-julia-repl hljs">julia&gt; myloglikelihood(x, μ) = loglikelihood(Normal(μ, 1), x);

julia&gt; @model function demo(x)
           μ ~ Normal()
           @addlogprob! myloglikelihood(x, μ)
       end;

julia&gt; x = [1.3, -2.1];

julia&gt; loglikelihood(demo(x), (μ=0.2,)) ≈ myloglikelihood(x, 0.2)
true</code></pre><p>and to <a href="https://github.com/TuringLang/Turing.jl/issues/1328">reject samples</a>:</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           m ~ MvNormal(zero(x), I)
           if dot(m, x) &lt; 0
               @addlogprob! -Inf
               # Exit the model evaluation early
               return
           end
           x ~ MvNormal(m, I)
           return
       end;

julia&gt; logjoint(demo([-2.1]), (m=[0.2],)) == -Inf
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>@addlogprob!</code> macro increases the accumulated log probability regardless of the evaluation context, i.e., regardless of whether you evaluate the log prior, the log likelihood or the log joint density. If you would like to avoid this behaviour you should check the evaluation context. It can be accessed with the internal variable <code>__context__</code>. For instance, in the following example the log density is not accumulated when only the log prior is computed:  </p><pre><code class="language-julia-repl hljs">julia&gt; myloglikelihood(x, μ) = loglikelihood(Normal(μ, 1), x);

julia&gt; @model function demo(x)
           μ ~ Normal()
           if DynamicPPL.leafcontext(__context__) !== PriorContext()
               @addlogprob! myloglikelihood(x, μ)
           end
       end;

julia&gt; x = [1.3, -2.1];

julia&gt; logprior(demo(x), (μ=0.2,)) ≈ logpdf(Normal(), 0.2)
true

julia&gt; loglikelihood(demo(x), (μ=0.2,)) ≈ myloglikelihood(x, 0.2)
true</code></pre></div></div></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/utils.jl#L5-L70" target="_blank">source</a></section></article><p>Return values of the model function for a collection of samples can be obtained with <a href="#DynamicPPL.generated_quantities"><code>generated_quantities</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.generated_quantities" id="DynamicPPL.generated_quantities"><code>DynamicPPL.generated_quantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generated_quantities(model::Model, chain::AbstractChains)</code></pre><p>Execute <code>model</code> for each of the samples in <code>chain</code> and return an array of the values returned by the <code>model</code> for each sample.</p><p><strong>Examples</strong></p><p><strong>General</strong></p><p>Often you might have additional quantities computed inside the model that you want to inspect, e.g.</p><pre><code class="language-julia hljs">@model function demo(x)
    # sample and observe
    θ ~ Prior()
    x ~ Likelihood()
    return interesting_quantity(θ, x)
end
m = demo(data)
chain = sample(m, alg, n)
# To inspect the `interesting_quantity(θ, x)` where `θ` is replaced by samples
# from the posterior/`chain`:
generated_quantities(m, chain) # &lt;= results in a `Vector` of returned values
                               #    from `interesting_quantity(θ, x)`</code></pre><p><strong>Concrete (and simple)</strong></p><pre><code class="language-julia hljs">julia&gt; using DynamicPPL, Turing

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10

           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           return (m, )
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(10));

julia&gt; chain = sample(model, MH(), 10);

julia&gt; generated_quantities(model, chain)
10×1 Array{Tuple{Float64},2}:
 (2.1964758025119338,)
 (2.1964758025119338,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.09270081916291417,)
 (0.043088571494005024,)
 (-0.16489786710222099,)
 (-0.16489786710222099,)</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L682-L740" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">generated_quantities(model::Model, parameters::NamedTuple)
generated_quantities(model::Model, values, keys)
generated_quantities(model::Model, values, keys)</code></pre><p>Execute <code>model</code> with variables <code>keys</code> set to <code>values</code> and return the values returned by the <code>model</code>.</p><p>If a <code>NamedTuple</code> is given, <code>keys=keys(parameters)</code> and <code>values=values(parameters)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions

julia&gt; @model function demo(xs)
           s ~ InverseGamma(2, 3)
           m_shifted ~ Normal(10, √s)
           m = m_shifted - 10
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end
           return (m, )
       end
demo (generic function with 2 methods)

julia&gt; model = demo(randn(10));

julia&gt; parameters = (; s = 1.0, m_shifted=10);

julia&gt; generated_quantities(model, parameters)
(0.0,)

julia&gt; generated_quantities(model, values(parameters), keys(parameters))
(0.0,)</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L750-L784" target="_blank">source</a></section></article><p>For a chain of samples, one can compute the pointwise log-likelihoods of each observed random variable with <a href="#DynamicPPL.pointwise_loglikelihoods"><code>pointwise_loglikelihoods</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.pointwise_loglikelihoods" id="DynamicPPL.pointwise_loglikelihoods"><code>DynamicPPL.pointwise_loglikelihoods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pointwise_loglikelihoods(model::Model, chain::Chains, keytype = String)</code></pre><p>Runs <code>model</code> on each sample in <code>chain</code> returning a <code>OrderedDict{String, Matrix{Float64}}</code> with keys corresponding to symbols of the observations, and values being matrices of shape <code>(num_chains, num_samples)</code>.</p><p><code>keytype</code> specifies what the type of the keys used in the returned <code>OrderedDict</code> are. Currently, only <code>String</code> and <code>VarName</code> are supported.</p><p><strong>Notes</strong></p><p>Say <code>y</code> is a <code>Vector</code> of <code>n</code> i.i.d. <code>Normal(μ, σ)</code> variables, with <code>μ</code> and <code>σ</code> both being <code>&lt;:Real</code>. Then the <em>observe</em> (i.e. when the left-hand side is an <em>observation</em>) statements can be implemented in three ways:</p><ol><li>using a <code>for</code> loop:</li></ol><pre><code class="language-julia hljs">for i in eachindex(y)
    y[i] ~ Normal(μ, σ)
end</code></pre><ol><li>using <code>.~</code>:</li></ol><pre><code class="language-julia hljs">y .~ Normal(μ, σ)</code></pre><ol><li>using <code>MvNormal</code>:</li></ol><pre><code class="language-julia hljs">y ~ MvNormal(fill(μ, n), σ^2 * I)</code></pre><p>In (1) and (2), <code>y</code> will be treated as a collection of <code>n</code> i.i.d. 1-dimensional variables, while in (3) <code>y</code> will be treated as a <em>single</em> n-dimensional observation.</p><p>This is important to keep in mind, in particular if the computation is used for downstream computations.</p><p><strong>Examples</strong></p><p><strong>From chain</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Turing

julia&gt; @model function demo(xs, y)
           s ~ InverseGamma(2, 3)
           m ~ Normal(0, √s)
           for i in eachindex(xs)
               xs[i] ~ Normal(m, √s)
           end

           y ~ Normal(m, √s)
       end
demo (generic function with 1 method)

julia&gt; model = demo(randn(3), randn());

julia&gt; chain = sample(model, MH(), 10);

julia&gt; pointwise_loglikelihoods(model, chain)
OrderedDict{String,Array{Float64,2}} with 4 entries:
  "xs[1]" =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  "xs[2]" =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  "xs[3]" =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]
  "y"     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]

julia&gt; pointwise_loglikelihoods(model, chain, String)
OrderedDict{String,Array{Float64,2}} with 4 entries:
  "xs[1]" =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  "xs[2]" =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  "xs[3]" =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]
  "y"     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]

julia&gt; pointwise_loglikelihoods(model, chain, VarName)
OrderedDict{VarName,Array{Float64,2}} with 4 entries:
  xs[1] =&gt; [-1.42932; -2.68123; … ; -1.66333; -1.66333]
  xs[2] =&gt; [-1.6724; -0.861339; … ; -1.62359; -1.62359]
  xs[3] =&gt; [-1.42862; -2.67573; … ; -1.66251; -1.66251]
  y     =&gt; [-1.51265; -0.914129; … ; -1.5499; -1.5499]</code></pre><p><strong>Broadcasting</strong></p><p>Note that <code>x .~ Dist()</code> will treat <code>x</code> as a collection of <em>independent</em> observations rather than as a single observation.</p><pre><code class="language-julia-repl hljs">julia&gt; @model function demo(x)
           x .~ Normal()
       end;

julia&gt; m = demo([1.0, ]);

julia&gt; ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first(ℓ[@varname(x[1])])
-1.4189385332046727

julia&gt; m = demo([1.0; 1.0]);

julia&gt; ℓ = pointwise_loglikelihoods(m, VarInfo(m)); first.((ℓ[@varname(x[1])], ℓ[@varname(x[2])]))
(-1.4189385332046727, -1.4189385332046727)</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/loglikelihoods.jl#L132-L229" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.NamedDist" id="DynamicPPL.NamedDist"><code>DynamicPPL.NamedDist</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A named distribution that carries the name of the random variable with it.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/distribution_wrappers.jl#L5-L7" target="_blank">source</a></section></article><h2 id="Testing-Utilities"><a class="docs-heading-anchor" href="#Testing-Utilities">Testing Utilities</a><a id="Testing-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Utilities" title="Permalink"></a></h2><p>DynamicPPL provides several demo models and helpers for testing samplers in the <code>DynamicPPL.TestUtils</code> submodule.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_sampler" id="DynamicPPL.TestUtils.test_sampler"><code>DynamicPPL.TestUtils.test_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_sampler(models, sampler, args...; kwargs...)</code></pre><p>Test that <code>sampler</code> produces correct marginal posterior means on each model in <code>models</code>.</p><p>In short, this method iterates through <code>models</code>, calls <code>AbstractMCMC.sample</code> on the <code>model</code> and <code>sampler</code> to produce a <code>chain</code>, and then checks <code>marginal_mean_of_samples(chain, vn)</code> for every (leaf) varname <code>vn</code> against the corresponding value returned by <a href="#DynamicPPL.TestUtils.posterior_mean"><code>posterior_mean</code></a> for each model.</p><p>To change how comparison is done for a particular <code>chain</code> type, one can overload <a href="#DynamicPPL.TestUtils.marginal_mean_of_samples"><code>marginal_mean_of_samples</code></a> for the corresponding type.</p><p><strong>Arguments</strong></p><ul><li><code>models</code>: A collection of instaces of <a href="#DynamicPPL.Model"><code>DynamicPPL.Model</code></a> to test on.</li><li><code>sampler</code>: The <code>AbstractMCMC.AbstractSampler</code> to test.</li><li><code>args...</code>: Arguments forwarded to <code>sample</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>varnames_filter</code>: A filter to apply to <code>varnames(model)</code>, allowing comparison for only   a subset of the varnames.</li><li><code>atol=1e-1</code>: Absolute tolerance used in <code>@test</code>.</li><li><code>rtol=1e-3</code>: Relative tolerance used in <code>@test</code>.</li><li><code>kwargs...</code>: Keyword arguments forwarded to <code>sample</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L713-L737" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_sampler_on_demo_models" id="DynamicPPL.TestUtils.test_sampler_on_demo_models"><code>DynamicPPL.TestUtils.test_sampler_on_demo_models</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_sampler_on_demo_models(meanfunction, sampler, args...; kwargs...)</code></pre><p>Test <code>sampler</code> on every model in <a href="#DynamicPPL.TestUtils.DEMO_MODELS"><code>DEMO_MODELS</code></a>.</p><p>This is just a proxy for <code>test_sampler(meanfunction, DEMO_MODELS, sampler, args...; kwargs...)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L762-L768" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_sampler_continuous" id="DynamicPPL.TestUtils.test_sampler_continuous"><code>DynamicPPL.TestUtils.test_sampler_continuous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_sampler_continuous(sampler, args...; kwargs...)</code></pre><p>Test that <code>sampler</code> produces the correct marginal posterior means on all models in <code>demo_models</code>.</p><p>As of right now, this is just an alias for <a href="#DynamicPPL.TestUtils.test_sampler_on_demo_models"><code>test_sampler_on_demo_models</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L775-L781" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.marginal_mean_of_samples" id="DynamicPPL.TestUtils.marginal_mean_of_samples"><code>DynamicPPL.TestUtils.marginal_mean_of_samples</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">marginal_mean_of_samples(chain, varname)</code></pre><p>Return the mean of variable represented by <code>varname</code> in <code>chain</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L706-L710" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.DEMO_MODELS" id="DynamicPPL.TestUtils.DEMO_MODELS"><code>DynamicPPL.TestUtils.DEMO_MODELS</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>A collection of models corresponding to the posterior distribution defined by the generative process</p><pre><code class="nohighlight hljs">s ~ InverseGamma(2, 3)
m ~ Normal(0, √s)
1.5 ~ Normal(m, √s)
2.0 ~ Normal(m, √s)</code></pre><p>or by</p><pre><code class="nohighlight hljs">s[1] ~ InverseGamma(2, 3)
s[2] ~ InverseGamma(2, 3)
m[1] ~ Normal(0, √s)
m[2] ~ Normal(0, √s)
1.5 ~ Normal(m[1], √s[1])
2.0 ~ Normal(m[2], √s[2])</code></pre><p>These are examples of a Normal-InverseGamma conjugate prior with Normal likelihood, for which the posterior is known in closed form.</p><p>In particular, for the univariate model (the former one):</p><pre><code class="nohighlight hljs">mean(s) == 49 / 24
mean(m) == 7 / 6</code></pre><p>And for the multivariate one (the latter one):</p><pre><code class="nohighlight hljs">mean(s[1]) == 19 / 8
mean(m[1]) == 3 / 4
mean(s[2]) == 8 / 3
mean(m[2]) == 1</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L624-L657" target="_blank">source</a></section></article><p>For every demo model, one can define the true log prior, log likelihood, and log joint probabilities.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true" id="DynamicPPL.TestUtils.logprior_true"><code>DynamicPPL.TestUtils.logprior_true</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logprior_true(model, args...)</code></pre><p>Return the <code>logprior</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L60-L68" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.loglikelihood_true" id="DynamicPPL.TestUtils.loglikelihood_true"><code>DynamicPPL.TestUtils.loglikelihood_true</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loglikelihood_true(model, args...)</code></pre><p>Return the <code>loglikelihood</code> of <code>model</code> for <code>args</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L71-L79" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true" id="DynamicPPL.TestUtils.logjoint_true"><code>DynamicPPL.TestUtils.logjoint_true</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logjoint_true(model, args...)</code></pre><p>Return the <code>logjoint</code> of <code>model</code> for <code>args</code>.</p><p>Defaults to <code>logprior_true(model, args...) + loglikelihood_true(model, args..)</code>.</p><p>This should generally be implemented by hand for every specific <code>model</code> so that the returned value can be used as a ground-truth for testing things like:</p><ol><li>Validity of evaluation of <code>model</code> using a particular implementation of <code>AbstractVarInfo</code>.</li><li>Validity of a sampler when combined with DynamicPPL by running the sampler twice: once targeting ground-truth functions, e.g. <code>logjoint_true</code>, and once targeting <code>model</code>.</li></ol><p>And more.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, <a href="#DynamicPPL.TestUtils.loglikelihood_true"><code>loglikelihood_true</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L82-L98" target="_blank">source</a></section></article><p>And in the case where the model includes constrained variables, it can also be useful to define</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian" id="DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logprior_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logprior_unconstrained)</code> of <code>model</code> for <code>args...</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>, the returned logprior computation includes the log-absdet-jacobian adjustment, thus computing logprior for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>See also: <a href="#DynamicPPL.TestUtils.logprior_true"><code>logprior_true</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L124-L136" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian" id="DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian"><code>DynamicPPL.TestUtils.logjoint_true_with_logabsdet_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">logjoint_true_with_logabsdet_jacobian(model::Model, args...)</code></pre><p>Return a tuple <code>(args_unconstrained, logjoint)</code> of <code>model</code> for <code>args</code>.</p><p>Unlike <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, the returned logjoint computation includes the log-absdet-jacobian adjustment, thus computing logjoint for the unconstrained variables.</p><p>Note that <code>args</code> are assumed be in the support of <code>model</code>, while <code>args_unconstrained</code> will be unconstrained.</p><p>This should generally not be implemented directly, instead one should implement <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a> for a given <code>model</code>.</p><p>See also: <a href="#DynamicPPL.TestUtils.logjoint_true"><code>logjoint_true</code></a>, <a href="#DynamicPPL.TestUtils.logprior_true_with_logabsdet_jacobian"><code>logprior_true_with_logabsdet_jacobian</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L103-L118" target="_blank">source</a></section></article><p>Finally, the following methods can also be of use:</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.varnames" id="DynamicPPL.TestUtils.varnames"><code>DynamicPPL.TestUtils.varnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">varnames(model::Model)</code></pre><p>Return a collection of <code>VarName</code> as they are expected to appear in the model.</p><p>Even though it is recommended to implement this by hand for a particular <code>Model</code>, a default implementation using <a href="#DynamicPPL.SimpleVarInfo"><code>SimpleVarInfo{&lt;:Dict}</code></a> is provided.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L139-L146" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.posterior_mean" id="DynamicPPL.TestUtils.posterior_mean"><code>DynamicPPL.TestUtils.posterior_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">posterior_mean(model::Model)</code></pre><p>Return a <code>NamedTuple</code> compatible with <code>varnames(model)</code> where the values represent the posterior mean under <code>model</code>.</p><p>"Compatible" means that a <code>varname</code> from <code>varnames(model)</code> can be used to extract the corresponding value using <code>get</code>, e.g. <code>get(posterior_mean(model), varname)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L153-L161" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.setup_varinfos" id="DynamicPPL.TestUtils.setup_varinfos"><code>DynamicPPL.TestUtils.setup_varinfos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setup_varinfos(model::Model, example_values::NamedTuple, varnames)</code></pre><p>Return a tuple of instances for different implementations of <code>AbstractVarInfo</code> with each <code>vi</code>, supposedly, satisfying <code>vi[vn] == get(example_values, vn)</code> for <code>vn</code> in <code>varnames</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L39-L44" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.update_values!!" id="DynamicPPL.TestUtils.update_values!!"><code>DynamicPPL.TestUtils.update_values!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_values!!(vi::AbstractVarInfo, vals::NamedTuple, vns)</code></pre><p>Return instance similar to <code>vi</code> but with <code>vns</code> set to values from <code>vals</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L16-L20" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TestUtils.test_values" id="DynamicPPL.TestUtils.test_values"><code>DynamicPPL.TestUtils.test_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">test_values(vi::AbstractVarInfo, vals::NamedTuple, vns)</code></pre><p>Test that <code>vi[vn]</code> corresponds to the correct value in <code>vals</code> for every <code>vn</code> in <code>vns</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/test_utils.jl#L28-L32" target="_blank">source</a></section></article><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2><h3 id="Variable-names"><a class="docs-heading-anchor" href="#Variable-names">Variable names</a><a id="Variable-names-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-names" title="Permalink"></a></h3><p>Names and possibly nested indices of variables are described with <code>AbstractPPL.VarName</code>. They can be defined with <code>AbstractPPL.@varname</code>. Please see the documentation of <a href="https://github.com/TuringLang/AbstractPPL.jl">AbstractPPL.jl</a> for further information.</p><h3 id="Data-Structures-of-Variables"><a class="docs-heading-anchor" href="#Data-Structures-of-Variables">Data Structures of Variables</a><a id="Data-Structures-of-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures-of-Variables" title="Permalink"></a></h3><p>DynamicPPL provides different data structures for samples from the model and their log density. All of them are subtypes of <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.AbstractVarInfo" id="DynamicPPL.AbstractVarInfo"><code>DynamicPPL.AbstractVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVarInfo</code></pre><p>Abstract supertype for data structures that capture random variables when executing a probabilistic model and accumulate log densities such as the log likelihood or the log joint probability of the model.</p><p>See also: <a href="#DynamicPPL.VarInfo"><code>VarInfo</code></a>, <a href="#DynamicPPL.SimpleVarInfo"><code>SimpleVarInfo</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/DynamicPPL.jl#L131-L139" target="_blank">source</a></section></article><h3 id="Common-API"><a class="docs-heading-anchor" href="#Common-API">Common API</a><a id="Common-API-1"></a><a class="docs-heading-anchor-permalink" href="#Common-API" title="Permalink"></a></h3><h4 id="Accumulation-of-log-probabilities"><a class="docs-heading-anchor" href="#Accumulation-of-log-probabilities">Accumulation of log-probabilities</a><a id="Accumulation-of-log-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Accumulation-of-log-probabilities" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.getlogp" id="DynamicPPL.getlogp"><code>DynamicPPL.getlogp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getlogp(vi::AbstractVarInfo)</code></pre><p>Return the log of the joint probability of the observed data and parameters sampled in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L72-L77" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.setlogp!!" id="DynamicPPL.setlogp!!"><code>DynamicPPL.setlogp!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setlogp!!(vi::AbstractVarInfo, logp)</code></pre><p>Set the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to <code>logp</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L80-L85" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.acclogp!!" id="DynamicPPL.acclogp!!"><code>DynamicPPL.acclogp!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">acclogp!!(vi::AbstractVarInfo, logp)</code></pre><p>Add <code>logp</code> to the value of the log of the joint probability of the observed data and parameters sampled in <code>vi</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L88-L93" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.resetlogp!!" id="DynamicPPL.resetlogp!!"><code>DynamicPPL.resetlogp!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resetlogp!!(vi::AbstractVarInfo)</code></pre><p>Reset the value of the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to 0, mutating if it makes sense.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L96-L101" target="_blank">source</a></section></article><h4 id="Variables-and-their-realizations"><a class="docs-heading-anchor" href="#Variables-and-their-realizations">Variables and their realizations</a><a id="Variables-and-their-realizations-1"></a><a class="docs-heading-anchor-permalink" href="#Variables-and-their-realizations" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" href="#Base.keys" id="Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(vi::AbstractVarInfo)</code></pre><p>Return an iterator over all <code>vns</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L105-L109" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex" id="Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindex(vi::AbstractVarInfo, vn::VarName[, dist::Distribution])
getindex(vi::AbstractVarInfo, vns::Vector{&lt;:VarName}[, dist::Distribution])</code></pre><p>Return the current value(s) of <code>vn</code> (<code>vns</code>) in <code>vi</code> in the support of its (their) distribution(s).</p><p>If <code>dist</code> is specified, the value(s) will be reshaped accordingly.</p><p>See also: <a href="#DynamicPPL.getindex_raw"><code>getindex_raw(vi::AbstractVarInfo, vn::VarName, dist::Distribution)</code></a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L111-L121" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.getindex_raw" id="DynamicPPL.getindex_raw"><code>DynamicPPL.getindex_raw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindex_raw(vi::AbstractVarInfo, vn::VarName[, dist::Distribution])
getindex_raw(vi::AbstractVarInfo, vns::Vector{&lt;:VarName}[, dist::Distribution])</code></pre><p>Return the current value(s) of <code>vn</code> (<code>vns</code>) in <code>vi</code>.</p><p>If <code>dist</code> is specified, the value(s) will be reshaped accordingly.</p><p>See also: <a href="#Base.getindex"><code>getindex(vi::AbstractVarInfo, vn::VarName, dist::Distribution)</code></a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The difference between <code>getindex(vi, vn, dist)</code> and <code>getindex_raw</code> is that  <code>getindex</code> will also transform the value(s) to the support of the distribution(s).  This is <em>not</em> the case for <code>getindex_raw</code>.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L137-L152" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#BangBang.push!!" id="BangBang.push!!"><code>BangBang.push!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> from a distribution <code>dist</code> to the <code>VarInfo</code><code>vi</code>, mutating if it makes sense.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L155-L160" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">push!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution, spl::AbstractSampler)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> sampled with a sampler <code>spl</code> from a distribution <code>dist</code> to <code>VarInfo</code><code>vi</code>, if it makes sense.</p><p>The sampler is passed here to invalidate its cache where defined.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is considered legacy, and is likely to be deprecated in the future.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L165-L174" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">push!!(vi::AbstractVarInfo, vn::VarName, r, dist::Distribution, gid::Selector)</code></pre><p>Push a new random variable <code>vn</code> with a sampled value <code>r</code> sampled with a sampler of selector <code>gid</code> from a distribution <code>dist</code> to <code>VarInfo</code><code>vi</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method is considered legacy, and is likely to be deprecated in the future.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L186-L193" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#BangBang.empty!!" id="BangBang.empty!!"><code>BangBang.empty!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!!(vi::AbstractVarInfo)</code></pre><p>Empty the fields of <code>vi.metadata</code> and reset <code>vi.logp[]</code> and <code>vi.num_produce[]</code> to zeros.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>vi</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L200-L207" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isempty" id="Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isempty(vi::AbstractVarInfo)</code></pre><p>Return true if <code>vi</code> is empty and false otherwise.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L209-L213" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.values_as" id="DynamicPPL.values_as"><code>DynamicPPL.values_as</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">values_as(varinfo[, Type])</code></pre><p>Return the values/realizations in <code>varinfo</code> as <code>Type</code>, if implemented.</p><p>If no <code>Type</code> is provided, return values as stored in <code>varinfo</code>.</p><p><strong>Examples</strong></p><p><code>SimpleVarInfo</code> with <code>NamedTuple</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; data = (x = 1.0, m = [2.0]);

julia&gt; values_as(SimpleVarInfo(data))
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), NamedTuple)
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), OrderedDict)
OrderedDict{VarName{sym, Setfield.IdentityLens} where sym, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>SimpleVarInfo</code> with <code>OrderedDict</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; data = OrderedDict{Any,Any}(@varname(x) =&gt; 1.0, @varname(m) =&gt; [2.0]);

julia&gt; values_as(SimpleVarInfo(data))
OrderedDict{Any, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), NamedTuple)
(x = 1.0, m = [2.0])

julia&gt; values_as(SimpleVarInfo(data), OrderedDict)
OrderedDict{Any, Any} with 2 entries:
  x =&gt; 1.0
  m =&gt; [2.0]

julia&gt; values_as(SimpleVarInfo(data), Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>TypedVarInfo</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; # Just use an example model to construct the `VarInfo` because we're lazy.
       vi = VarInfo(DynamicPPL.TestUtils.demo_assume_dot_observe());

julia&gt; vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;

julia&gt; # For the sake of brevity, let's just check the type.
       md = values_as(vi); md.s isa DynamicPPL.Metadata
true

julia&gt; values_as(vi, NamedTuple)
(s = 1.0, m = 2.0)

julia&gt; values_as(vi, OrderedDict)
OrderedDict{VarName{sym, Setfield.IdentityLens} where sym, Float64} with 2 entries:
  s =&gt; 1.0
  m =&gt; 2.0

julia&gt; values_as(vi, Vector)
2-element Vector{Float64}:
 1.0
 2.0</code></pre><p><code>UntypedVarInfo</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; # Just use an example model to construct the `VarInfo` because we're lazy.
       vi = VarInfo(); DynamicPPL.TestUtils.demo_assume_dot_observe()(vi);

julia&gt; vi[@varname(s)] = 1.0; vi[@varname(m)] = 2.0;

julia&gt; # For the sake of brevity, let's just check the type.
       values_as(vi) isa DynamicPPL.Metadata
true

julia&gt; values_as(vi, NamedTuple)
(s = 1.0, m = 2.0)

julia&gt; values_as(vi, OrderedDict)
OrderedDict{VarName{sym, Setfield.IdentityLens} where sym, Float64} with 2 entries:
  s =&gt; 1.0
  m =&gt; 2.0

julia&gt; values_as(vi, Vector)
2-element Vector{Real}:
 1.0
 2.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L215-L321" target="_blank">source</a></section></article><h4 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.AbstractTransformation" id="DynamicPPL.AbstractTransformation"><code>DynamicPPL.AbstractTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTransformation</code></pre><p>Represents a transformation to be used in <code>link!!</code> and <code>invlink!!</code>, amongst others.</p><p>A concrete implementation of this should implement the following methods:</p><ul><li><a href="#DynamicPPL.link!!"><code>link!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the unconstrained space.</li><li><a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>: transforms the <a href="#DynamicPPL.AbstractVarInfo"><code>AbstractVarInfo</code></a> to the constrained space.</li></ul><p>And potentially:</p><ul><li><a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>: hook to decide whether to transform <em>before</em> evaluating the model.</li></ul><p>See also: <a href="#DynamicPPL.link!!"><code>link!!</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>, <a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L2-L16" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.NoTransformation" id="DynamicPPL.NoTransformation"><code>DynamicPPL.NoTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NoTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which applies the identity function.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L19-L23" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.DynamicTransformation" id="DynamicPPL.DynamicTransformation"><code>DynamicPPL.DynamicTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DynamicTransformation &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which transforms the variables on a per-need-basis in the execution of a given <code>Model</code>.</p><p>This is in constrast to <code>StaticTransformation</code> which transforms all variables <em>before</em> the execution of a given <code>Model</code>.</p><p>See also: <a href="#DynamicPPL.StaticTransformation"><code>StaticTransformation</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L26-L36" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.StaticTransformation" id="DynamicPPL.StaticTransformation"><code>DynamicPPL.StaticTransformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct StaticTransformation{F} &lt;: DynamicPPL.AbstractTransformation</code></pre><p>Transformation which transforms all variables <em>before</em> the execution of a given <code>Model</code>.</p><p>This is done through the <code>maybe_invlink_before_eval!!</code> method.</p><p>See also: <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>, <a href="#DynamicPPL.maybe_invlink_before_eval!!"><code>maybe_invlink_before_eval!!</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>bijector::Any</code>: The function, assumed to implement the <code>Bijectors</code> interface, to be applied to the variables</li></ul></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L39-L50" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.istrans" id="DynamicPPL.istrans"><code>DynamicPPL.istrans</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">istrans(vi::AbstractVarInfo[, vns::Union{VarName, AbstractVector{&lt;:Varname}}])</code></pre><p>Return <code>true</code> if <code>vi</code> is working in unconstrained space, and <code>false</code> if <code>vi</code> is assuming realizations to be in support of the corresponding distributions.</p><p>If <code>vns</code> is provided, then only check if this/these varname(s) are transformed.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Not all implementations of <code>AbstractVarInfo</code> support transforming only a subset of the variables.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L341-L352" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.settrans!!" id="DynamicPPL.settrans!!"><code>DynamicPPL.settrans!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">settrans!!(vi::AbstractVarInfo, trans::Bool[, vn::VarName])</code></pre><p>Return <code>vi</code> with <code>istrans(vi, vn)</code> evaluating to <code>true</code>.</p><p>If <code>vn</code> is not specified, then <code>istrans(vi)</code> evaluates to <code>true</code> for all variables.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L358-L364" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.transformation" id="DynamicPPL.transformation"><code>DynamicPPL.transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transformation(vi::AbstractVarInfo)</code></pre><p>Return the <code>AbstractTransformation</code> related to <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L64-L68" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.link!!" id="DynamicPPL.link!!"><code>DynamicPPL.link!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
link!!([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)</code></pre><p>Transforms the variables in <code>vi</code> to their linked space, using the transformation <code>t</code>.</p><p>If <code>t</code> is not provided, <code>default_transformation(model, vi)</code> will be used.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.invlink!!"><code>invlink!!</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L367-L376" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.invlink!!" id="DynamicPPL.invlink!!"><code>DynamicPPL.invlink!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, model::Model)
invlink!!([t::AbstractTransformation, ]vi::AbstractVarInfo, spl::AbstractSampler, model::Model)</code></pre><p>Transform the variables in <code>vi</code> to their constrained space, using the (inverse of)  transformation <code>t</code>.</p><p>If <code>t</code> is not provided, <code>default_transformation(model, vi)</code> will be used.</p><p>See also: <a href="#DynamicPPL.default_transformation"><code>default_transformation</code></a>, <a href="#DynamicPPL.link!!"><code>link!!</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L386-L396" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.default_transformation" id="DynamicPPL.default_transformation"><code>DynamicPPL.default_transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_transformation(model::Model[, vi::AbstractVarInfo])</code></pre><p>Return the <code>AbstractTransformation</code> currently related to <code>model</code> and, potentially, <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L56-L60" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.maybe_invlink_before_eval!!" id="DynamicPPL.maybe_invlink_before_eval!!"><code>DynamicPPL.maybe_invlink_before_eval!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maybe_invlink_before_eval!!([t::Transformation,] vi, context, model)</code></pre><p>Return a possibly invlinked version of <code>vi</code>.</p><p>This will be called prior to <code>model</code> evaluation, allowing one to perform a single <code>invlink!!</code><em>before</em> evaluation rather than lazyily evaluating the transforms on as-we-need basis as is done with <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>.</p><p>See also: <a href="#DynamicPPL.StaticTransformation"><code>StaticTransformation</code></a>, <a href="#DynamicPPL.DynamicTransformation"><code>DynamicTransformation</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DynamicPPL, Distributions, Bijectors

julia&gt; @model demo() = x ~ Normal()
demo (generic function with 2 methods)

julia&gt; # By subtyping `Transform`, we inherit the `(inv)link!!`.
       struct MyBijector &lt;: Bijectors.Transform end

julia&gt; # Define some dummy `inverse` which will be used in the `link!!` call.
       Bijectors.inverse(f::MyBijector) = identity

julia&gt; # We need to define `with_logabsdet_jacobian` for `MyBijector`
       # (`identity` already has `with_logabsdet_jacobian` defined)
       function Bijectors.with_logabsdet_jacobian(::MyBijector, x)
           # Just using a large number of the logabsdet-jacobian term
           # for demonstration purposes.
           return (x, 1000)
       end

julia&gt; # Change the `default_transformation` for our model to be a
       # `StaticTransformation` using `MyBijector`.
       function DynamicPPL.default_transformation(::Model{typeof(demo)})
           return DynamicPPL.StaticTransformation(MyBijector())
       end

julia&gt; model = demo();

julia&gt; vi = SimpleVarInfo(x=1.0)
SimpleVarInfo((x = 1.0,), 0.0)

julia&gt; # Uses the `inverse` of `MyBijector`, which we have defined as `identity`
       vi_linked = link!!(vi, model)
Transformed SimpleVarInfo((x = 1.0,), 0.0)

julia&gt; # Now performs a single `invlink!!` before model evaluation.
       logjoint(model, vi_linked)
-1001.4189385332047</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L437-L488" target="_blank">source</a></section></article><h4 id="Utils"><a class="docs-heading-anchor" href="#Utils">Utils</a><a id="Utils-1"></a><a class="docs-heading-anchor-permalink" href="#Utils" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.unflatten" id="DynamicPPL.unflatten"><code>DynamicPPL.unflatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unflatten(original, x::AbstractVector)</code></pre><p>Return instance of <code>original</code> constructed from <code>x</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/utils.jl#L444-L448" target="_blank">source</a></section><section><div><pre><code class="nohighlight hljs">unflatten(vi::AbstractVarInfo[, context::AbstractContext], x::AbstractVector)</code></pre><p>Return a new instance of <code>vi</code> with the values of <code>x</code> assigned to the variables.</p><p>If <code>context</code> is provided, <code>x</code> is assumed to be realizations only for variables not filtered out by <code>context</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L520-L527" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.tonamedtuple" id="DynamicPPL.tonamedtuple"><code>DynamicPPL.tonamedtuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tonamedtuple(vi::AbstractVarInfo)</code></pre><p>Convert a <code>vi</code> into a <code>NamedTuple</code> where each variable symbol maps to the values and  indexing string of the variable.</p><p>For example, a model that had a vector of vector-valued variables <code>x</code> would return</p><pre><code class="language-julia hljs">(x = ([1.5, 2.0], [3.0, 1.0], ["x[1]", "x[2]"]), )</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/abstract_varinfo.jl#L541-L553" target="_blank">source</a></section></article><h4 id="SimpleVarInfo"><a class="docs-heading-anchor" href="#SimpleVarInfo"><code>SimpleVarInfo</code></a><a id="SimpleVarInfo-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleVarInfo" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.SimpleVarInfo" id="DynamicPPL.SimpleVarInfo"><code>DynamicPPL.SimpleVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SimpleVarInfo{NT, T, C&lt;:DynamicPPL.AbstractTransformation} &lt;: AbstractVarInfo</code></pre><p>A simple wrapper of the parameters with a <code>logp</code> field for accumulation of the logdensity.</p><p>Currently only implemented for <code>NT&lt;:NamedTuple</code> and <code>NT&lt;:AbstractDict</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>values</code>: underlying representation of the realization represented</p></li><li><p><code>logp</code>: holds the accumulated log-probability</p></li><li><p><code>transformation</code>: represents whether it assumes variables to be transformed</p></li></ul><p><strong>Notes</strong></p><p>The major differences between this and <code>TypedVarInfo</code> are:</p><ol><li><code>SimpleVarInfo</code> does not require linearization.</li><li><code>SimpleVarInfo</code> can use more efficient bijectors.</li><li><code>SimpleVarInfo</code> is only type-stable if <code>NT&lt;:NamedTuple</code> and either a) no indexing is used in tilde-statements, or b) the values have been specified with the correct shapes.</li></ol><p><strong>Examples</strong></p><p><strong>General usage</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs

julia&gt; @model function demo()
           m ~ Normal()
           x = Vector{Float64}(undef, 2)
           for i in eachindex(x)
               x[i] ~ Normal()
           end
           return x
       end
demo (generic function with 2 methods)

julia&gt; m = demo();

julia&gt; rng = StableRNG(42);

julia&gt; ### Sampling ###
       ctx = SamplingContext(rng, SampleFromPrior(), DefaultContext());

julia&gt; # In the `NamedTuple` version we need to provide the place-holder values for
       # the variables which are using "containers", e.g. `Array`.
       # In this case, this means that we need to specify `x` but not `m`.
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo((x = ones(2), )), ctx);

julia&gt; # (✓) Vroom, vroom! FAST!!!
       vi[@varname(x[1])]
0.4471218424633827

julia&gt; # We can also access arbitrary varnames pointing to `x`, e.g.
       vi[@varname(x)]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; vi[@varname(x[1:2])]
2-element Vector{Float64}:
 0.4471218424633827
 1.3736306979834252

julia&gt; # (×) If we don't provide the container...
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx); vi
ERROR: type NamedTuple has no field x
[...]

julia&gt; # If one does not know the varnames, we can use a `OrderedDict` instead.
       _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo{Float64}(OrderedDict()), ctx);

julia&gt; # (✓) Sort of fast, but only possible at runtime.
       vi[@varname(x[1])]
-1.019202452456547

julia&gt; # In addtion, we can only access varnames as they appear in the model!
       vi[@varname(x)]
ERROR: KeyError: key x not found
[...]

julia&gt; vi[@varname(x[1:2])]
ERROR: KeyError: key x[1:2] not found
[...]</code></pre><p><em>Technically</em>, it's possible to use any implementation of <code>AbstractDict</code> in place of <code>OrderedDict</code>, but <code>OrderedDict</code> ensures that certain operations, e.g. linearization/flattening of the values in the varinfo, are consistent between evaluations. Hence <code>OrderedDict</code> is the preferred implementation of <code>AbstractDict</code> to use here.</p><p>You can also sample in <em>transformed</em> space:</p><pre><code class="language-julia-repl hljs">julia&gt; @model demo_constrained() = x ~ Exponential()
demo_constrained (generic function with 2 methods)

julia&gt; m = demo_constrained();

julia&gt; _, vi = DynamicPPL.evaluate!!(m, SimpleVarInfo(), ctx);

julia&gt; vi[@varname(x)] # (✓) 0 ≤ x &lt; ∞
1.8632965762164932

julia&gt; _, vi = DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx);

julia&gt; vi[@varname(x)] # (✓) -∞ &lt; x &lt; ∞
-0.21080155351918753

julia&gt; xs = [last(DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx))[@varname(x)] for i = 1:10];

julia&gt; any(xs .&lt; 0)  # (✓) Positive probability mass on negative numbers!
true

julia&gt; # And with `OrderedDict` of course!
       _, vi = DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(OrderedDict()), true), ctx);

julia&gt; vi[@varname(x)] # (✓) -∞ &lt; x &lt; ∞
0.6225185067787314

julia&gt; xs = [last(DynamicPPL.evaluate!!(m, DynamicPPL.settrans!!(SimpleVarInfo(), true), ctx))[@varname(x)] for i = 1:10];

julia&gt; any(xs .&lt; 0) # (✓) Positive probability mass on negative numbers!
true</code></pre><p>Evaluation in transformed space of course also works:</p><pre><code class="language-julia-repl hljs">julia&gt; vi = DynamicPPL.settrans!!(SimpleVarInfo((x = -1.0,)), true)
Transformed SimpleVarInfo((x = -1.0,), 0.0)

julia&gt; # (✓) Positive probability mass on negative numbers!
       getlogp(last(DynamicPPL.evaluate!!(m, vi, DynamicPPL.DefaultContext())))
-1.3678794411714423

julia&gt; # While if we forget to indicate that it's transformed:
       vi = DynamicPPL.settrans!!(SimpleVarInfo((x = -1.0,)), false)
SimpleVarInfo((x = -1.0,), 0.0)

julia&gt; # (✓) No probability mass on negative numbers!
       getlogp(last(DynamicPPL.evaluate!!(m, vi, DynamicPPL.DefaultContext())))
-Inf</code></pre><p><strong>Indexing</strong></p><p>Using <code>NamedTuple</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_nt = SimpleVarInfo((m = (a = [1.0], ), ));

julia&gt; svi_nt[@varname(m)]
(a = [1.0],)

julia&gt; svi_nt[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_nt[@varname(m.a[1])]
1.0

julia&gt; svi_nt[@varname(m.a[2])]
ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]
[...]

julia&gt; svi_nt[@varname(m.b)]
ERROR: type NamedTuple has no field b
[...]</code></pre><p>Using <code>OrderedDict</code> as underlying storage.</p><pre><code class="language-julia-repl hljs">julia&gt; svi_dict = SimpleVarInfo(OrderedDict(@varname(m) =&gt; (a = [1.0], )));

julia&gt; svi_dict[@varname(m)]
(a = [1.0],)

julia&gt; svi_dict[@varname(m.a)]
1-element Vector{Float64}:
 1.0

julia&gt; svi_dict[@varname(m.a[1])]
1.0

julia&gt; svi_dict[@varname(m.a[2])]
ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]
[...]

julia&gt; svi_dict[@varname(m.b)]
ERROR: type NamedTuple has no field b
[...]</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/simple_varinfo.jl#L1-L190" target="_blank">source</a></section></article><h4 id="VarInfo"><a class="docs-heading-anchor" href="#VarInfo"><code>VarInfo</code></a><a id="VarInfo-1"></a><a class="docs-heading-anchor-permalink" href="#VarInfo" title="Permalink"></a></h4><p>Another data structure is <a href="#DynamicPPL.VarInfo"><code>VarInfo</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.VarInfo" id="DynamicPPL.VarInfo"><code>DynamicPPL.VarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VarInfo{Tmeta, Tlogp} &lt;: AbstractVarInfo
    metadata::Tmeta
    logp::Base.RefValue{Tlogp}
    num_produce::Base.RefValue{Int}
end</code></pre><p>A light wrapper over one or more instances of <code>Metadata</code>. Let <code>vi</code> be an instance of <code>VarInfo</code>. If <code>vi isa VarInfo{&lt;:Metadata}</code>, then only one <code>Metadata</code> instance is used for all the sybmols. <code>VarInfo{&lt;:Metadata}</code> is aliased <code>UntypedVarInfo</code>. If <code>vi isa VarInfo{&lt;:NamedTuple}</code>, then <code>vi.metadata</code> is a <code>NamedTuple</code> that maps each symbol used on the LHS of <code>~</code> in the model to its <code>Metadata</code> instance. The latter allows for the type specialization of <code>vi</code> after the first sampling iteration when all the symbols have been observed. <code>VarInfo{&lt;:NamedTuple}</code> is aliased <code>TypedVarInfo</code>.</p><p>Note: It is the user's responsibility to ensure that each "symbol" is visited at least once whenever the model is called, regardless of any stochastic branching. Each symbol refers to a Julia variable and can be a hierarchical array of many random variables, e.g. <code>x[1] ~ ...</code> and <code>x[2] ~ ...</code> both have the same symbol <code>x</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L78-L98" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.TypedVarInfo" id="DynamicPPL.TypedVarInfo"><code>DynamicPPL.TypedVarInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TypedVarInfo(vi::UntypedVarInfo)</code></pre><p>This function finds all the unique <code>sym</code>s from the instances of <code>VarName{sym}</code> found in <code>vi.metadata.vns</code>. It then extracts the metadata associated with each symbol from the global <code>vi.metadata</code> field. Finally, a new <code>VarInfo</code> is created with a new <code>metadata</code> as a <code>NamedTuple</code> mapping from symbols to type-stable <code>Metadata</code> instances, one for each symbol.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L555-L563" target="_blank">source</a></section></article><p>One main characteristic of <a href="#DynamicPPL.VarInfo"><code>VarInfo</code></a> is that samples are stored in a linearized form.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.link!" id="DynamicPPL.link!"><code>DynamicPPL.link!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">link!(vi::VarInfo, spl::Sampler)</code></pre><p>Transform the values of the random variables sampled by <code>spl</code> in <code>vi</code> from the support of their distributions to the Euclidean space and set their corresponding <code>"trans"</code> flag values to <code>true</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L721-L727" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.invlink!" id="DynamicPPL.invlink!"><code>DynamicPPL.invlink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invlink!(vi::VarInfo, spl::AbstractSampler)</code></pre><p>Transform the values of the random variables sampled by <code>spl</code> in <code>vi</code> from the Euclidean space back to the support of their distributions and sets their corresponding <code>"trans"</code> flag values to <code>false</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L815-L821" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.set_flag!" id="DynamicPPL.set_flag!"><code>DynamicPPL.set_flag!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_flag!(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Set <code>vn</code>'s value for <code>flag</code> to <code>true</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L538-L542" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.unset_flag!" id="DynamicPPL.unset_flag!"><code>DynamicPPL.unset_flag!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unset_flag!(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Set <code>vn</code>'s value for <code>flag</code> to <code>false</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L1168-L1172" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.is_flagged" id="DynamicPPL.is_flagged"><code>DynamicPPL.is_flagged</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_flagged(vi::VarInfo, vn::VarName, flag::String)</code></pre><p>Check whether <code>vn</code> has a true value for <code>flag</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L1159-L1163" target="_blank">source</a></section></article><p>For Gibbs sampling the following functions were added.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.setgid!" id="DynamicPPL.setgid!"><code>DynamicPPL.setgid!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setgid!(vi::VarInfo, gid::Selector, vn::VarName)</code></pre><p>Add <code>gid</code> to the set of sampler selectors associated with <code>vn</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L652-L656" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.updategid!" id="DynamicPPL.updategid!"><code>DynamicPPL.updategid!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updategid!(vi::VarInfo, vn::VarName, spl::Sampler)</code></pre><p>Set <code>vn</code>'s <code>gid</code> to <code>Set([spl.selector])</code>, if <code>vn</code> does not have a sampler selector linked and <code>vn</code>'s symbol is in the space of <code>spl</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L1233-L1238" target="_blank">source</a></section></article><p>The following functions were used for sequential Monte Carlo methods.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.get_num_produce" id="DynamicPPL.get_num_produce"><code>DynamicPPL.get_num_produce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_produce(vi::VarInfo)</code></pre><p>Return the <code>num_produce</code> of <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L675-L679" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.set_num_produce!" id="DynamicPPL.set_num_produce!"><code>DynamicPPL.set_num_produce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_num_produce!(vi::VarInfo, n::Int)</code></pre><p>Set the <code>num_produce</code> field of <code>vi</code> to <code>n</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L682-L686" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.increment_num_produce!" id="DynamicPPL.increment_num_produce!"><code>DynamicPPL.increment_num_produce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">increment_num_produce!(vi::VarInfo)</code></pre><p>Add 1 to <code>num_produce</code> in <code>vi</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L689-L693" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.reset_num_produce!" id="DynamicPPL.reset_num_produce!"><code>DynamicPPL.reset_num_produce!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reset_num_produce!(vi::VarInfo)</code></pre><p>Reset the value of <code>num_produce</code> the log of the joint probability of the observed data and parameters sampled in <code>vi</code> to 0.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L696-L701" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.setorder!" id="DynamicPPL.setorder!"><code>DynamicPPL.setorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setorder!(vi::VarInfo, vn::VarName, index::Int)</code></pre><p>Set the <code>order</code> of <code>vn</code> in <code>vi</code> to <code>index</code>, where <code>order</code> is the number of <code>observe statements run before sampling</code>vn`.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L1141-L1146" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.set_retained_vns_del_by_spl!" id="DynamicPPL.set_retained_vns_del_by_spl!"><code>DynamicPPL.set_retained_vns_del_by_spl!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_retained_vns_del_by_spl!(vi::VarInfo, spl::Sampler)</code></pre><p>Set the <code>"del"</code> flag of variables in <code>vi</code> with <code>order &gt; vi.num_produce[]</code> to <code>true</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L1178-L1182" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.empty!" id="Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty!(meta::Metadata)</code></pre><p>Empty the fields of <code>meta</code>.</p><p>This is useful when using a sampling algorithm that assumes an empty <code>meta</code>, e.g. <code>SMC</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/varinfo.jl#L210-L216" target="_blank">source</a></section></article><h3 id="Evaluation-Contexts"><a class="docs-heading-anchor" href="#Evaluation-Contexts">Evaluation Contexts</a><a id="Evaluation-Contexts-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation-Contexts" title="Permalink"></a></h3><p>Internally, both sampling and evaluation of log densities are performed with <a href="#AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a>.</p><article class="docstring"><header><a class="docstring-binding" href="#AbstractPPL.evaluate!!" id="AbstractPPL.evaluate!!"><code>AbstractPPL.evaluate!!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate!!(model::Model[, rng, varinfo, sampler, context])</code></pre><p>Sample from the <code>model</code> using the <code>sampler</code> with random number generator <code>rng</code> and the <code>context</code>, and store the sample and log joint probability in <code>varinfo</code>.</p><p>Returns both the return-value of the original model, and the resulting varinfo.</p><p>The method resets the log joint probability of <code>varinfo</code> and increases the evaluation number of <code>sampler</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/model.jl#L487-L497" target="_blank">source</a></section></article><p>The behaviour of a model execution can be changed with evaluation contexts that are passed as additional argument to the model function. Contexts are subtypes of <code>AbstractPPL.AbstractContext</code>.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.SamplingContext" id="DynamicPPL.SamplingContext"><code>DynamicPPL.SamplingContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingContext(
        [rng::Random.AbstractRNG=Random.default_rng()],
        [sampler::AbstractSampler=SampleFromPrior()],
        [context::AbstractContext=DefaultContext()],
)</code></pre><p>Create a context that allows you to sample parameters with the <code>sampler</code> when running the model. The <code>context</code> determines how the returned log density is computed when running the model.</p><p>See also: <a href="#DynamicPPL.DefaultContext"><code>DefaultContext</code></a>, <a href="#DynamicPPL.LikelihoodContext"><code>LikelihoodContext</code></a>, <a href="#DynamicPPL.PriorContext"><code>PriorContext</code></a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L122-L133" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.DefaultContext" id="DynamicPPL.DefaultContext"><code>DynamicPPL.DefaultContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefaultContext &lt;: AbstractContext end</code></pre><p>The <code>DefaultContext</code> is used by default to compute log the joint probability of the data  and parameters when running the model.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L188-L193" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.LikelihoodContext" id="DynamicPPL.LikelihoodContext"><code>DynamicPPL.LikelihoodContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LikelihoodContext{Tvars} &lt;: AbstractContext
    vars::Tvars
end</code></pre><p>The <code>LikelihoodContext</code> enables the computation of the log likelihood of the parameters when  running the model. <code>vars</code> can be used to evaluate the log likelihood for specific values  of the model's parameters. If <code>vars</code> is <code>nothing</code>, the parameter values inside the <code>VarInfo</code> will be used by default.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L211-L219" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.PriorContext" id="DynamicPPL.PriorContext"><code>DynamicPPL.PriorContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PriorContext{Tvars} &lt;: AbstractContext
    vars::Tvars
end</code></pre><p>The <code>PriorContext</code> enables the computation of the log prior of the parameters <code>vars</code> when  running the model.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L197-L204" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.MiniBatchContext" id="DynamicPPL.MiniBatchContext"><code>DynamicPPL.MiniBatchContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MiniBatchContext{Tctx, T} &lt;: AbstractContext
    context::Tctx
    loglike_scalar::T
end</code></pre><p>The <code>MiniBatchContext</code> enables the computation of  <code>log(prior) + s * log(likelihood of a batch)</code> when running the model, where <code>s</code> is the  <code>loglike_scalar</code> field, typically equal to <code>the number of data points / batch size</code>.  This is useful in batch-based stochastic gradient descent algorithms to be optimizing  <code>log(prior) + log(likelihood of all the data points)</code> in the expectation.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L226-L237" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.PrefixContext" id="DynamicPPL.PrefixContext"><code>DynamicPPL.PrefixContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrefixContext{Prefix}(context)</code></pre><p>Create a context that allows you to use the wrapped <code>context</code> when running the model and adds the <code>Prefix</code> to all parameters.</p><p>This context is useful in nested models to ensure that the names of the parameters are unique.</p><p>See also: <a href="#DynamicPPL.@submodel"><code>@submodel</code></a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/contexts.jl#L251-L261" target="_blank">source</a></section></article><h3 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h3><p>In DynamicPPL two samplers are defined that are used to initialize unobserved random variables: <a href="#DynamicPPL.SampleFromPrior"><code>SampleFromPrior</code></a> which samples from the prior distribution, and <a href="#DynamicPPL.SampleFromUniform"><code>SampleFromUniform</code></a> which samples from a uniform distribution.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.SampleFromPrior" id="DynamicPPL.SampleFromPrior"><code>DynamicPPL.SampleFromPrior</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleFromPrior</code></pre><p>Sampling algorithm that samples unobserved random variables from their prior distribution.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L14-L18" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.SampleFromUniform" id="DynamicPPL.SampleFromUniform"><code>DynamicPPL.SampleFromUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampleFromUniform</code></pre><p>Sampling algorithm that samples unobserved random variables from a uniform distribution.</p><p><strong>References</strong></p><p><a href="https://mc-stan.org/docs/2_28/reference-manual/initialization.html#random-initial-values">Stan reference manual</a></p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L3-L11" target="_blank">source</a></section></article><p>Additionally, a generic sampler for inference is implemented.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.Sampler" id="DynamicPPL.Sampler"><code>DynamicPPL.Sampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sampler{T}</code></pre><p>Generic sampler type for inference algorithms of type <code>T</code> in DynamicPPL.</p><p><code>Sampler</code> should implement the AbstractMCMC interface, and in particular <code>AbstractMCMC.step</code>. A default implementation of the initial sampling step is provided that supports resuming sampling from a previous state and setting initial parameter values. It requires to overload <a href="#DynamicPPL.loadstate"><code>loadstate</code></a> and <a href="#DynamicPPL.initialstep"><code>initialstep</code></a> for loading previous states and actually performing the initial sampling step, respectively. Additionally, sometimes one might want to implement <a href="#DynamicPPL.initialsampler"><code>initialsampler</code></a> that specifies how the initial parameter values are sampled if they are not provided. By default, values are sampled from the prior.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L34-L47" target="_blank">source</a></section></article><p>The default implementation of <a href="#DynamicPPL.Sampler"><code>Sampler</code></a> uses the following unexported functions.</p><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.initialstep" id="DynamicPPL.initialstep"><code>DynamicPPL.initialstep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialstep(rng, model, sampler, varinfo; kwargs...)</code></pre><p>Perform the initial sampling step of the <code>sampler</code> for the <code>model</code>.</p><p>The <code>varinfo</code> contains the initial samples, which can be provided by the user or sampled randomly.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L167-L174" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.loadstate" id="DynamicPPL.loadstate"><code>DynamicPPL.loadstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loadstate(data)</code></pre><p>Load sampler state from <code>data</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L114-L118" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.initialsampler" id="DynamicPPL.initialsampler"><code>DynamicPPL.initialsampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialsampler(sampler::Sampler)</code></pre><p>Return the sampler that is used for generating the initial parameters when sampling with <code>sampler</code>.</p><p>By default, it returns an instance of <a href="#DynamicPPL.SampleFromPrior"><code>SampleFromPrior</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/sampler.jl#L121-L128" target="_blank">source</a></section></article><h3 id="model_internal"><a class="docs-heading-anchor" href="#model_internal">Model-Internal Functions</a><a id="model_internal-1"></a><a class="docs-heading-anchor-permalink" href="#model_internal" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.tilde_assume" id="DynamicPPL.tilde_assume"><code>DynamicPPL.tilde_assume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tilde_assume(context::SamplingContext, right, vn, vi)</code></pre><p>Handle assumed variables, e.g., <code>x ~ Normal()</code> (where <code>x</code> does occur in the model inputs), accumulate the log probability, and return the sampled value with a context associated with a sampler.</p><p>Falls back to</p><pre><code class="language-julia hljs">tilde_assume(context.rng, context.context, context.sampler, right, vn, vi)</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/context_implementations.jl#L18-L29" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.dot_tilde_assume" id="DynamicPPL.dot_tilde_assume"><code>DynamicPPL.dot_tilde_assume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_assume(context::SamplingContext, right, left, vn, vi)</code></pre><p>Handle broadcasted assumed variables, e.g., <code>x .~ MvNormal()</code> (where <code>x</code> does not occur in the model inputs), accumulate the log probability, and return the sampled value for a context associated with a sampler.</p><p>Falls back to</p><pre><code class="language-julia hljs">dot_tilde_assume(context.rng, context.context, context.sampler, right, left, vn, vi)</code></pre></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/context_implementations.jl#L244-L255" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.tilde_observe" id="DynamicPPL.tilde_observe"><code>DynamicPPL.tilde_observe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tilde_observe(context::SamplingContext, right, left, vi)</code></pre><p>Handle observed constants with a <code>context</code> associated with a sampler.</p><p>Falls back to <code>tilde_observe(context.context, context.sampler, right, left, vi)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/context_implementations.jl#L122-L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#DynamicPPL.dot_tilde_observe" id="DynamicPPL.dot_tilde_observe"><code>DynamicPPL.dot_tilde_observe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dot_tilde_observe(context::SamplingContext, right, left, vi)</code></pre><p>Handle broadcasted observed constants, e.g., <code>[1.0] .~ MvNormal()</code>, accumulate the log probability, and return the observed value for a context associated with a sampler.</p><p>Falls back to <code>dot_tilde_observe(context.context, context.sampler, right, left, vi)</code>.</p></div><a class="docs-sourcelink" href="https://github.com/TuringLang/DynamicPPL.jl/blob/40a4ebaf297c34e95f441fe9d8cf6cac874cde86/src/context_implementations.jl#L567-L574" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials/prob-interface/">The Probability Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 1 June 2023 11:56">Thursday 1 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>